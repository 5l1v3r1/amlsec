package org.sba_research

import com.typesafe.scalalogging.Logger
import org.apache.jena.datatypes.xsd.XSDDatatype
import org.apache.jena.ontology.OntModel
import org.apache.jena.rdf.model.{InfModel, RDFNode, ResourceFactory}
import org.sba_research.model.OntModels

import scala.annotation.tailrec
import scala.collection.JavaConverters._

object VulnerabilityModeling {

  val logger = Logger(getClass)

  val cveVulnIndvPrefix = "Vulnerability"

  def processReport(config: Config, ontModels: OntModels, infModel: InfModel, validationReport: ValidationReport): Option[OntModels] =
    performReportProcessing(config, Some(ontModels), infModel, validationReport.validationResults)

  @tailrec
  private def performReportProcessing(config: Config, ontModels: Option[OntModels], infModel: InfModel, validationResults: List[ValidationResult]): Option[OntModels] =
    validationResults match {
      case x :: xs => OntModelUtils.removeNamespace(x.sourceShape) match {
        case "ActiveCopyProtection" =>
          performReportProcessing(config, instantiateVulnerabilityNoPlcProgramCopyProtection(config, ontModels, x.focusNode), infModel, xs)
        case "ActiveKnowHowProtection" =>
          performReportProcessing(config, instantiateVulnerabilityNoPlcProgramKnowHowProtection(config, ontModels, x.focusNode), infModel, xs)
        case "HasRefPartnerLinkMin1Shape" =>
          performReportProcessing(config, instantiateVulnerabilityUnusedOpenPort(config, ontModels, infModel, x.focusNode), infModel, xs)
        case "InsecureProtocolInUse" =>
          performReportProcessing(config, instantiateVulnerabilityInsecureProtocolUsed(config, ontModels, infModel, x.focusNode), infModel, xs)
        case "InsecureAlgorithmInUse" =>
          performReportProcessing(config, instantiateVulnerabilityInsecureAlgorithmUsed(config, ontModels, infModel, x.focusNode), infModel, xs)
        case "CrossZoneConnections" =>
          performReportProcessing(config, instantiateVulnerabilityUntrustedCrossZoneConnection(config, ontModels, infModel, x.focusNode), infModel, xs)
        case "ITOTCrossConnections" =>
          performReportProcessing(config, instantiateVulnerabilityItOtCrossConnection(config, ontModels, infModel, x.focusNode), infModel, xs)
        case "TempConnections" =>
          performReportProcessing(config, instantiateVulnerabilityTemporaryConnection(config, ontModels, infModel, x.focusNode), infModel, xs)
        case "ExtConnections" =>
          performReportProcessing(config, instantiateVulnerabilityExtConnection(config, ontModels, infModel, x.focusNode), infModel, xs)
        case "SafetyAssetsZone" =>
          performReportProcessing(config, instantiateVulnerabilitySafetyAssetsZone(config, ontModels, infModel, x.focusNode), infModel, xs)
        case "SafetyAssetsConnectionZone" =>
          performReportProcessing(config, instantiateVulnerabilitySafetyNonSafetyZoneCrossConnection(config, ontModels, infModel, x.focusNode), infModel, xs)
        case "WirelessAssetsZone" =>
          performReportProcessing(config, instantiateVulnerabilityNotSeparatedWirelessDevice(config, ontModels, infModel, x.focusNode), infModel, xs)
        case "WirelessAssetsConnectionZone" =>
          performReportProcessing(config, instantiateVulnerabilityWirelessWiredZoneCrossConnection(config, ontModels, infModel, x.focusNode), infModel, xs)
      }
      case Nil => ontModels
    }


  private def instantiateVulnerabilityNoPlcProgramCopyProtection(config: Config, ontModels: Option[OntModels], focusNode: String): Option[OntModels] = ontModels map { o =>
    val vulnIndv = o.aml.getIndividual(s"${config.icsSecOntConfig.ns}#NoPLCProgramCopyProtection")
    val focusIndv = o.aml.getIndividual(focusNode)
    vulnIndv.addProperty(getVulnerabilityOnAssetObjectProperty(config, o), focusIndv)
    o
  }

  private def instantiateVulnerabilityNoPlcProgramKnowHowProtection(config: Config, ontModels: Option[OntModels], focusNode: String): Option[OntModels] = ontModels map { o =>
    val vulnIndv = o.aml.getIndividual(s"${config.icsSecOntConfig.ns}#NoPLCProgramKnowHowProtection")
    val focusIndv = o.aml.getIndividual(focusNode)
    vulnIndv.addProperty(getVulnerabilityOnAssetObjectProperty(config, o), focusIndv)
    o
  }

  private def instantiateVulnerabilityUnusedOpenPort(config: Config, ontModels: Option[OntModels], infModel: InfModel, focusNode: String): Option[OntModels] = ontModels map { o =>
    val vulnIndv = o.aml.getIndividual(s"${config.secOntConfig.ns}#UnusedOpenPort")
    /* Obtaining the asset from the logical endpoint. */
    val focusIndv = infModel.getDeductionsModel.getResource(focusNode)
    val hasEIInvProperty = infModel.getDeductionsModel.getProperty(s"${config.amlConfig.nsOnt}#hasEIInv")
    val hasIEInvProperty = infModel.getDeductionsModel.getProperty(s"${config.amlConfig.nsOnt}#hasIEInv")
    val asset = infModel
      /* Based on logical endpoint, get logical portlist */
      .listStatements(focusIndv, hasEIInvProperty, null)
      .asScala.nextOption()
      .map(_.getObject)
      .flatMap { logicalPortList =>
        /* Go even one hierarchy up to obtain the asset. */
        infModel.listStatements(logicalPortList.asResource(), hasIEInvProperty, null).asScala.nextOption.map(_.getObject)
      }
    asset map { a => vulnIndv.addProperty(getVulnerabilityOnAssetObjectProperty(config, o), a.asResource) }
    o
  }

  private def instantiateVulnerabilityInsecureProtocolUsed(config: Config, ontModels: Option[OntModels], infModel: InfModel, focusNode: String): Option[OntModels] = ontModels map { o =>
    val vulnIndv = o.aml.getIndividual(s"${config.secOntConfig.ns}#InsecureProtocolUsed")
    val assets = getAssetFromLogicalOrPhysicalConnection(config, o.aml, infModel, focusNode)
    assets.foreach(asset => vulnIndv.addProperty(getVulnerabilityOnAssetObjectProperty(config, o), asset))
    o
  }

  private def instantiateVulnerabilityInsecureAlgorithmUsed(config: Config, ontModels: Option[OntModels], infModel: InfModel, focusNode: String): Option[OntModels] = ontModels map { o =>
    val vulnIndv = o.aml.getIndividual(s"${config.secOntConfig.ns}#InsecureAlgorithmUsed")
    val focusIndv = o.aml.getIndividual(focusNode)
    val queryResult = QueryExecutor.query(
      s =
        s"""
           |PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
           |PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
           |PREFIX owl: <http://www.w3.org/2002/07/owl#>
           |PREFIX amlImp: <http://www.ipr.kit.edu/aml_importer#>
           |PREFIX amlOnt: <http://www.ipr.kit.edu/aml_ontology#>
           |PREFIX icsSecOnt: <http://securityontology.com/icssecont#>
           |PREFIX secOnt: <http://securityontology.com/secont#>
           |SELECT DISTINCT ?asset
           |   WHERE {
           |      ?asset rdf:type ?assetType .
           |      ?assetType rdfs:subClassOf* secOnt:Asset .
           |      ?asset amlOnt:hasIE+ <${focusIndv.toString}> .
           |   }
        """.stripMargin,
      infModel = infModel,
      resBinding = None
    )
    queryResult.values.foreach { binding =>
      val value = queryResult.variables.find(_.getVarName == "asset").map(binding.get)
      value.map(v => vulnIndv.addProperty(getVulnerabilityOnAssetObjectProperty(config, o), o.aml.getIndividual(v.getURI)))
    }
    o
  }

  private def instantiateVulnerabilityUntrustedCrossZoneConnection(config: Config, ontModels: Option[OntModels], infModel: InfModel, focusNode: String): Option[OntModels] = ontModels map { o =>
    val vulnIndv = o.aml.getIndividual(s"${config.icsSecOntConfig.ns}#UntrustedCrossZoneConnection")
    val assets = getAssetFromLogicalOrPhysicalConnection(config, o.aml, infModel, focusNode)
    assets.foreach(asset => vulnIndv.addProperty(getVulnerabilityOnAssetObjectProperty(config, o), asset))
    o
  }

  private def instantiateVulnerabilityItOtCrossConnection(config: Config, ontModels: Option[OntModels], infModel: InfModel, focusNode: String): Option[OntModels] = ontModels map { o =>
    val vulnIndv = o.aml.getIndividual(s"${config.icsSecOntConfig.ns}#ITOTCrossConnection")
    val assets = getAssetFromLogicalOrPhysicalConnection(config, o.aml, infModel, focusNode)
    assets.foreach(asset => vulnIndv.addProperty(getVulnerabilityOnAssetObjectProperty(config, o), asset))
    o
  }

  private def instantiateVulnerabilityTemporaryConnection(config: Config, ontModels: Option[OntModels], infModel: InfModel, focusNode: String): Option[OntModels] = ontModels map { o =>
    val vulnIndv = o.aml.getIndividual(s"${config.icsSecOntConfig.ns}#NotSeparatedTemporarilyConnectedDevice")
    val focusIndv = o.aml.getIndividual(focusNode)
    vulnIndv.addProperty(getVulnerabilityOnAssetObjectProperty(config, o), focusIndv)
    o
  }

  private def instantiateVulnerabilityExtConnection(config: Config, ontModels: Option[OntModels], infModel: InfModel, focusNode: String): Option[OntModels] = ontModels map { o =>
    val vulnIndv = o.aml.getIndividual(s"${config.icsSecOntConfig.ns}#NotSeparatedDeviceConnectedToExternalNetworks")
    val focusIndv = o.aml.getIndividual(focusNode)
    vulnIndv.addProperty(getVulnerabilityOnAssetObjectProperty(config, o), focusIndv)
    o
  }

  private def instantiateVulnerabilitySafetyAssetsZone(config: Config, ontModels: Option[OntModels], infModel: InfModel, focusNode: String): Option[OntModels] = ontModels map { o =>
    val vulnIndv = o.aml.getIndividual(s"${config.icsSecOntConfig.ns}#NotSeparatedSafetyRelatedDevice")
    val focusIndv = o.aml.getIndividual(focusNode)
    vulnIndv.addProperty(getVulnerabilityOnAssetObjectProperty(config, o), focusIndv)
    o
  }

  private def instantiateVulnerabilitySafetyNonSafetyZoneCrossConnection(config: Config, ontModels: Option[OntModels], infModel: InfModel, focusNode: String): Option[OntModels] = ontModels map { o =>
    val vulnIndv = o.aml.getIndividual(s"${config.icsSecOntConfig.ns}#SafetyNonSafetyZoneCrossConnection")
    val assets = getAssetFromLogicalOrPhysicalConnection(config, o.aml, infModel, focusNode)
    assets.foreach(asset => vulnIndv.addProperty(getVulnerabilityOnAssetObjectProperty(config, o), asset))
    o
  }

  private def instantiateVulnerabilityNotSeparatedWirelessDevice(config: Config, ontModels: Option[OntModels], infModel: InfModel, focusNode: String): Option[OntModels] = ontModels map { o =>
    val vulnIndv = o.aml.getIndividual(s"${config.icsSecOntConfig.ns}#NotSeparatedWirelessDevice")
    val focusIndv = o.aml.getIndividual(focusNode)
    vulnIndv.addProperty(getVulnerabilityOnAssetObjectProperty(config, o), focusIndv)
    o
  }

  private def instantiateVulnerabilityWirelessWiredZoneCrossConnection(config: Config, ontModels: Option[OntModels], infModel: InfModel, focusNode: String): Option[OntModels] = ontModels map { o =>
    val vulnIndv = o.aml.getIndividual(s"${config.icsSecOntConfig.ns}#WirelessWiredZoneCrossConnection")
    val assets = getAssetFromLogicalOrPhysicalConnection(config, o.aml, infModel, focusNode)
    assets.foreach(asset => vulnIndv.addProperty(getVulnerabilityOnAssetObjectProperty(config, o), asset))
    o
  }

  private def getAssetFromLogicalOrPhysicalConnection(config: Config, ontModel: OntModel, infModel: InfModel, focusNode: String): Iterator[RDFNode] = {
    val focusIndv = ontModel.getIndividual(focusNode)
    val hasEIProperty = ontModel.getObjectProperty(s"${config.amlConfig.nsOnt}#hasEI")
    // val hasIEProperty = ontModel.getObjectProperty(s"${config.amlConfig.nsOnt}#hasIE")
    val hasEIInvProperty = infModel.getDeductionsModel.getProperty(s"${config.amlConfig.nsOnt}#hasEIInv")
    val hasIEInvProperty = infModel.getDeductionsModel.getProperty(s"${config.amlConfig.nsOnt}#hasIEInv")
    val hasRefPartnerProperty = infModel.getDeductionsModel.getProperty(s"${config.amlConfig.nsOnt}#hasRefPartner")
    val hasRefPartnerSideAProperty = infModel.getDeductionsModel.getProperty(s"${config.amlConfig.nsOnt}#hasRefPartnerSideA")
    val assets =
    /* Obtain logical endpoint from logical or physical connection. */
      focusIndv.listProperties(hasEIProperty).asScala
        .map(_.getObject)
        .flatMap { endpointA =>
          /* Obtain link. */
          infModel
            .listStatements(endpointA.asResource(), hasRefPartnerProperty, null)
            .asScala.nextOption()
            .map(_.getObject)
            .flatMap { link =>
              /* Obtain object of hasRefPartnerSideA (but exclude currently processed logical endpoint). */
              infModel
                .listStatements(link.asResource(), hasRefPartnerSideAProperty, null).asScala
                .map(_.getObject)
                .filterNot(rdfNode => rdfNode.toString.equals(endpointA.toString))
                .nextOption()
            }
            .flatMap { endpointB =>
              /* Obtain object logical or physical portlist. */
              infModel
                .listStatements(endpointB.asResource(), hasEIInvProperty, null)
                .asScala.nextOption()
                .map(_.getObject)
            }
            .flatMap { portlist =>
              /* Finally, obtain asset. */
              infModel
                .listStatements(portlist.asResource(), hasIEInvProperty, null)
                .asScala.nextOption()
                .map(_.getObject)
            }
        }
    assets
  }

  private def getVulnerabilityOnAssetObjectProperty(config: Config, ontModels: OntModels) =
    ontModels.aml.getObjectProperty(s"${config.secOntConfig.ns}#vulnerability_on_Asset")

  private def getVulnerabilityExploitedByThreatObjectProperty(config: Config, ontModels: OntModels) =
    ontModels.aml.getObjectProperty(s"${config.secOntConfig.ns}#vulnerability_exploitedBy_Threat")

  def processCves(config: Config, ontModels: OntModels, resultSetBinding: ResultSetBinding): Option[OntModels] = {
    val queryResult = QueryExecutor.query(
      s =
        s"""
           |PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
           |PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
           |PREFIX owl: <http://www.w3.org/2002/07/owl#>
           |PREFIX amlImp: <http://www.ipr.kit.edu/aml_importer#>
           |PREFIX amlOnt: <http://www.ipr.kit.edu/aml_ontology#>
           |PREFIX icsSecOnt: <http://securityontology.com/icssecont#>
           |PREFIX secOnt: <http://securityontology.com/secont#>
           |SELECT DISTINCT ?cve ?cveId ?cpe ?version ?other ?part ?product ?productName ?vendor ?vendorName ?indvAml ?cvss ?cvssBaseScore
           |   WHERE {
           |      ?indvAml amlImp:hasCpePart ?part.
           |      ?indvAml amlImp:hasCpeVendor ?vendorName.
           |      ?indvAml amlImp:hasCpeProduct ?productName.
           |      ?indvAml amlImp:hasCpeVersion ?version.
           |   }
        """.stripMargin,
      ontModel = ontModels.aml,
      Some(resultSetBinding)
    )
    val vulnOntCls = ontModels.aml.getOntClass(s"${config.secOntConfig.ns}#Vulnerability")
    val vulnerableSoftwareIndv = ontModels.aml.getIndividual(s"${config.secOntConfig.ns}#VulnerableSoftware")
    val vulnerabilityCveDataProperty = ontModels.aml.getDatatypeProperty(s"${config.secOntConfig.ns}#vulnerability_has_Cve")
    val vulnerabilityCvssDataProperty = ontModels.aml.getDatatypeProperty(s"${config.secOntConfig.ns}#vulnerability_has_SeverityValue")

    queryResult.values.foreach { binding =>
      val cveIdentifier = queryResult.variables.find(_.getVarName == "cveId").map(binding.get)
      val amlIndv = queryResult.variables.find(_.getVarName == "indvAml").map(binding.get)
      val sepsesCveIndv = queryResult.variables.find(_.getVarName == "cve").map(binding.get)
      val sepsesCvssBaseScore = queryResult.variables.find(_.getVarName == "cvssBaseScore").flatMap(x => Option(binding.get(x))) // can be null, wrap with Option
      for {
        cveId <- cveIdentifier
        amlI <- amlIndv
        cveI <- sepsesCveIndv
        vulnIndv <- Some(ontModels.aml.createIndividual(s"${config.secOntConfig.ns}#${cveId.toString.replace("\"", "")}", vulnOntCls))
      } yield {
        vulnIndv.addProperty(getVulnerabilityExploitedByThreatObjectProperty(config, ontModels), vulnerableSoftwareIndv)
        vulnIndv.addProperty(getVulnerabilityOnAssetObjectProperty(config, ontModels), ontModels.aml.getIndividual(amlI.getURI))
        vulnIndv.addProperty(vulnerabilityCveDataProperty, ResourceFactory.createTypedLiteral(cveI.getURI, XSDDatatype.XSDanyURI))
        // In case CVSS exists, add property
        sepsesCvssBaseScore foreach {
          cvss => vulnIndv.addProperty(vulnerabilityCvssDataProperty, ResourceFactory.createTypedLiteral(cvss.getLiteral.getValue.toString, XSDDatatype.XSDdouble))
        }
      }
    }
    Some(ontModels)
  }

}
