package org.sba_research.vuln

import com.typesafe.scalalogging.Logger
import org.apache.jena.datatypes.xsd.XSDDatatype
import org.apache.jena.ontology.OntModel
import org.apache.jena.rdf.model.{InfModel, RDFNode, ResourceFactory}
import org.sba_research.Config
import org.sba_research.utils._

import scala.annotation.tailrec
import scala.jdk.CollectionConverters._

object VulnerabilityModeling {

  val logger = Logger(getClass)

  val cveVulnIndvPrefix = "Vulnerability"

  def processReport(config: Config, ontModel: OntModel, infModel: Option[InfModel], validationReport: ValidationReport): Option[OntModel] = validationReport.validationResults match {
    case l: List[_] =>
      val shaclValidationResultList = l.map { case s: ShaclValidationResult => s }
      performReportProcessing(config, Some(ontModel), infModel, shaclValidationResultList)
    case _ =>
      logger.error("Could not match validation results to list composed of SHACL validation results.")
      None
  }


  @tailrec
  def processReports(config: Config, ontModel: Option[OntModel], infModel: Option[InfModel], validationReports: List[ValidationReport]): Option[OntModel] =
    validationReports match {
      case x :: xs =>
        x.validationResults match {
          case l: List[_] =>
            val shaclValidationResultList = l.map { case s: ShaclValidationResult => s }
            processReports(config, performReportProcessing(config, ontModel, infModel, shaclValidationResultList), infModel, xs)
          case _ =>
            logger.error("Could not match validation results to list composed of SHACL validation results.")
            processReports(config, ontModel, infModel, xs)
        }
      case Nil => ontModel
    }


  @tailrec
  private def performReportProcessing(config: Config, ontModel: Option[OntModel], infModel: Option[InfModel], validationResults: List[ShaclValidationResult]): Option[OntModel] =
    validationResults match {
      case x :: xs => OntModelUtils.removeNamespace(x.sourceShape) match {
        case "ActiveCopyProtection" =>
          performReportProcessing(config, instantiateVulnerabilityNoPlcProgramCopyProtection(config, ontModel, x.focusNode), infModel, xs)
        case "ActiveKnowHowProtection" =>
          performReportProcessing(config, instantiateVulnerabilityNoPlcProgramKnowHowProtection(config, ontModel, x.focusNode), infModel, xs)
        case "HasRefPartnerLinkMin1Shape" =>
          performReportProcessing(config, instantiateVulnerabilityUnusedOpenPort(config, ontModel, infModel, x.focusNode), infModel, xs)
        case "InsecureProtocolInUse" =>
          performReportProcessing(config, instantiateVulnerabilityInsecureProtocolUsed(config, ontModel, infModel, x.focusNode), infModel, xs)
        case "InsecureAlgorithmInUse" =>
          performReportProcessing(config, instantiateVulnerabilityInsecureAlgorithmUsed(config, ontModel, infModel, x.focusNode), infModel, xs)
        case "CrossZoneConnections" =>
          performReportProcessing(config, instantiateVulnerabilityUntrustedCrossZoneConnection(config, ontModel, infModel, x.focusNode), infModel, xs)
        case "ITOTCrossConnections" =>
          performReportProcessing(config, instantiateVulnerabilityItOtCrossConnection(config, ontModel, infModel, x.focusNode), infModel, xs)
        case "TempConnections" =>
          performReportProcessing(config, instantiateVulnerabilityTemporaryConnection(config, ontModel, infModel, x.focusNode), infModel, xs)
        case "ExtConnections" =>
          performReportProcessing(config, instantiateVulnerabilityExtConnection(config, ontModel, infModel, x.focusNode), infModel, xs)
        case "SafetyAssetsZone" =>
          performReportProcessing(config, instantiateVulnerabilitySafetyAssetsZone(config, ontModel, infModel, x.focusNode), infModel, xs)
        case "SafetyAssetsConnectionZone" =>
          performReportProcessing(config, instantiateVulnerabilitySafetyNonSafetyZoneCrossConnection(config, ontModel, infModel, x.focusNode), infModel, xs)
        case "WirelessAssetsZone" =>
          performReportProcessing(config, instantiateVulnerabilityNotSeparatedWirelessDevice(config, ontModel, infModel, x.focusNode), infModel, xs)
        case "WirelessAssetsConnectionZone" =>
          performReportProcessing(config, instantiateVulnerabilityWirelessWiredZoneCrossConnection(config, ontModel, infModel, x.focusNode), infModel, xs)
      }
      case Nil => ontModel
    }


  private def instantiateVulnerabilityNoPlcProgramCopyProtection(config: Config, ontModel: Option[OntModel], focusNode: String): Option[OntModel] = ontModel map { om =>
    val vulnIndv = om.getIndividual(s"${config.icsSecOntConfig.ns}#NoPLCProgramCopyProtection")
    val focusIndv = om.getIndividual(focusNode)
    vulnIndv.addProperty(getVulnerabilityOnAssetObjectProperty(config, om), focusIndv)
    om
  }

  private def instantiateVulnerabilityNoPlcProgramKnowHowProtection(config: Config, ontModel: Option[OntModel], focusNode: String): Option[OntModel] = ontModel map { om =>
    val vulnIndv = om.getIndividual(s"${config.icsSecOntConfig.ns}#NoPLCProgramKnowHowProtection")
    val focusIndv = om.getIndividual(focusNode)
    vulnIndv.addProperty(getVulnerabilityOnAssetObjectProperty(config, om), focusIndv)
    om
  }

  private def instantiateVulnerabilityUnusedOpenPort(config: Config, ontModel: Option[OntModel], infModel: Option[InfModel], focusNode: String): Option[OntModel] = ontModel map { om =>
    val vulnIndv = om.getIndividual(s"${config.secOntConfig.ns}#UnusedOpenPort")
    /* If inference model exists, we assume that no materialization has been done beforehand in ontModel. */
    val deductionsModelOrMaterializedOntModel = infModel.map(_.getDeductionsModel).getOrElse(om)
    val infModelOrMaterializedOntModel = infModel.getOrElse(om)
    /* Obtaining the asset from the logical endpoint. */
    val focusIndv = deductionsModelOrMaterializedOntModel.getResource(focusNode)
    val hasEIInvProperty = deductionsModelOrMaterializedOntModel.getProperty(s"${config.amlConfig.nsOnt}#hasEIInv")
    val hasIEInvProperty = deductionsModelOrMaterializedOntModel.getProperty(s"${config.amlConfig.nsOnt}#hasIEInv")
    val asset = infModelOrMaterializedOntModel
      /* Based on logical endpoint, get logical portlist */
      .listStatements(focusIndv, hasEIInvProperty, null)
      .asScala.nextOption()
      .map(_.getObject)
      .flatMap { logicalPortList =>
        /* Go even one hierarchy up to obtain the asset. */
        infModelOrMaterializedOntModel.listStatements(logicalPortList.asResource(), hasIEInvProperty, null).asScala.nextOption.map(_.getObject)
      }
    asset map { a => vulnIndv.addProperty(getVulnerabilityOnAssetObjectProperty(config, om), a.asResource) }
    om
  }

  private def instantiateVulnerabilityInsecureProtocolUsed(config: Config, ontModel: Option[OntModel], infModel: Option[InfModel], focusNode: String): Option[OntModel] = ontModel map { om =>
    val vulnIndv = om.getIndividual(s"${config.secOntConfig.ns}#InsecureProtocolUsed")
    val assets = getAssetFromLogicalOrPhysicalConnection(config, om, infModel, focusNode)
    assets.foreach(asset => vulnIndv.addProperty(getVulnerabilityOnAssetObjectProperty(config, om), asset))
    om
  }

  private def instantiateVulnerabilityInsecureAlgorithmUsed(config: Config, ontModel: Option[OntModel], infModel: Option[InfModel], focusNode: String): Option[OntModel] = ontModel map { om =>
    /* If inference model exists, we assume that no materialization has been done beforehand in ontModel. */
    val infModelOrMaterializedOntModel = infModel.getOrElse(om)
    val vulnIndv = om.getIndividual(s"${config.secOntConfig.ns}#InsecureAlgorithmUsed")
    val focusIndv = om.getIndividual(focusNode)
    val queryResult = QueryExecutor.query(
      s =
        s"""
           |PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
           |PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
           |PREFIX owl: <http://www.w3.org/2002/07/owl#>
           |PREFIX amlImp: <http://www.ipr.kit.edu/aml_importer#>
           |PREFIX amlOnt: <http://www.ipr.kit.edu/aml_ontology#>
           |PREFIX icsSecOnt: <http://securityontology.com/icssecont#>
           |PREFIX secOnt: <http://securityontology.com/secont#>
           |SELECT DISTINCT ?asset
           |   WHERE {
           |      ?asset rdf:type ?assetType .
           |      ?assetType rdfs:subClassOf* secOnt:Asset .
           |      ?asset amlOnt:hasIE+ <${focusIndv.toString}> .
           |   }
        """.stripMargin,
      model = infModelOrMaterializedOntModel,
      resBinding = None
    )
    queryResult.values.foreach { binding =>
      val value = queryResult.variables.find(_.getVarName == "asset").map(binding.get)
      value.map(v => vulnIndv.addProperty(getVulnerabilityOnAssetObjectProperty(config, om), om.getIndividual(v.getURI)))
    }
    om
  }

  private def instantiateVulnerabilityUntrustedCrossZoneConnection(config: Config, ontModel: Option[OntModel], infModel: Option[InfModel], focusNode: String): Option[OntModel] = ontModel map { om =>
    val vulnIndv = om.getIndividual(s"${config.icsSecOntConfig.ns}#UntrustedCrossZoneConnection")
    val assets = getAssetFromLogicalOrPhysicalConnection(config, om, infModel, focusNode)
    assets.foreach(asset => vulnIndv.addProperty(getVulnerabilityOnAssetObjectProperty(config, om), asset))
    om
  }

  private def instantiateVulnerabilityItOtCrossConnection(config: Config, ontModel: Option[OntModel], infModel: Option[InfModel], focusNode: String): Option[OntModel] = ontModel map { om =>
    val vulnIndv = om.getIndividual(s"${config.icsSecOntConfig.ns}#ITOTCrossConnection")
    val assets = getAssetFromLogicalOrPhysicalConnection(config, om, infModel, focusNode)
    assets.foreach(asset => vulnIndv.addProperty(getVulnerabilityOnAssetObjectProperty(config, om), asset))
    om
  }

  private def instantiateVulnerabilityTemporaryConnection(config: Config, ontModel: Option[OntModel], infModel: Option[InfModel], focusNode: String): Option[OntModel] = ontModel map { om =>
    val vulnIndv = om.getIndividual(s"${config.icsSecOntConfig.ns}#NotSeparatedTemporarilyConnectedDevice")
    val focusIndv = om.getIndividual(focusNode)
    vulnIndv.addProperty(getVulnerabilityOnAssetObjectProperty(config, om), focusIndv)
    om
  }

  private def instantiateVulnerabilityExtConnection(config: Config, ontModel: Option[OntModel], infModel: Option[InfModel], focusNode: String): Option[OntModel] = ontModel map { om =>
    val vulnIndv = om.getIndividual(s"${config.icsSecOntConfig.ns}#NotSeparatedDeviceConnectedToExternalNetworks")
    val focusIndv = om.getIndividual(focusNode)
    vulnIndv.addProperty(getVulnerabilityOnAssetObjectProperty(config, om), focusIndv)
    om
  }

  private def instantiateVulnerabilitySafetyAssetsZone(config: Config, ontModel: Option[OntModel], infModel: Option[InfModel], focusNode: String): Option[OntModel] = ontModel map { om =>
    val vulnIndv = om.getIndividual(s"${config.icsSecOntConfig.ns}#NotSeparatedSafetyRelatedDevice")
    val focusIndv = om.getIndividual(focusNode)
    vulnIndv.addProperty(getVulnerabilityOnAssetObjectProperty(config, om), focusIndv)
    om
  }

  private def instantiateVulnerabilitySafetyNonSafetyZoneCrossConnection(config: Config, ontModel: Option[OntModel], infModel: Option[InfModel], focusNode: String): Option[OntModel] = ontModel map { om =>
    val vulnIndv = om.getIndividual(s"${config.icsSecOntConfig.ns}#SafetyNonSafetyZoneCrossConnection")
    val assets = getAssetFromLogicalOrPhysicalConnection(config, om, infModel, focusNode)
    assets.foreach(asset => vulnIndv.addProperty(getVulnerabilityOnAssetObjectProperty(config, om), asset))
    om
  }

  private def instantiateVulnerabilityNotSeparatedWirelessDevice(config: Config, ontModel: Option[OntModel], infModel: Option[InfModel], focusNode: String): Option[OntModel] = ontModel map { om =>
    val vulnIndv = om.getIndividual(s"${config.icsSecOntConfig.ns}#NotSeparatedWirelessDevice")
    val focusIndv = om.getIndividual(focusNode)
    vulnIndv.addProperty(getVulnerabilityOnAssetObjectProperty(config, om), focusIndv)
    om
  }

  private def instantiateVulnerabilityWirelessWiredZoneCrossConnection(config: Config, ontModel: Option[OntModel], infModel: Option[InfModel], focusNode: String): Option[OntModel] = ontModel map { om =>
    val vulnIndv = om.getIndividual(s"${config.icsSecOntConfig.ns}#WirelessWiredZoneCrossConnection")
    val assets = getAssetFromLogicalOrPhysicalConnection(config, om, infModel, focusNode)
    assets.foreach(asset => vulnIndv.addProperty(getVulnerabilityOnAssetObjectProperty(config, om), asset))
    om
  }

  private def getAssetFromLogicalOrPhysicalConnection(config: Config, ontModel: OntModel, infModel: Option[InfModel], focusNode: String): Iterator[RDFNode] = {
    /* If inference model exists, we assume that no materialization has been done beforehand in ontModel. */
    val deductionsModelOrMaterializedOntModel = infModel.map(_.getDeductionsModel).getOrElse(ontModel)
    val infModelOrMaterializedOntModel = infModel.getOrElse(ontModel)
    val focusIndv = ontModel.getIndividual(focusNode)
    val hasEIProperty = ontModel.getObjectProperty(s"${config.amlConfig.nsOnt}#hasEI")
    // val hasIEProperty = ontModel.getObjectProperty(s"${config.amlConfig.nsOnt}#hasIE")
    val hasEIInvProperty = deductionsModelOrMaterializedOntModel.getProperty(s"${config.amlConfig.nsOnt}#hasEIInv")
    val hasIEInvProperty = deductionsModelOrMaterializedOntModel.getProperty(s"${config.amlConfig.nsOnt}#hasIEInv")
    val hasRefPartnerProperty = deductionsModelOrMaterializedOntModel.getProperty(s"${config.amlConfig.nsOnt}#hasRefPartner")
    val hasRefPartnerSideAProperty = deductionsModelOrMaterializedOntModel.getProperty(s"${config.amlConfig.nsOnt}#hasRefPartnerSideA")
    val assets =
    /* Obtain logical endpoint from logical or physical connection. */
      focusIndv.listProperties(hasEIProperty).asScala
        .map(_.getObject)
        .flatMap { endpointA =>
          /* Obtain link. */
          infModelOrMaterializedOntModel
            .listStatements(endpointA.asResource(), hasRefPartnerProperty, null)
            .asScala.nextOption()
            .map(_.getObject)
            .flatMap { link =>
              /* Obtain object of hasRefPartnerSideA (but exclude currently processed logical endpoint). */
              infModelOrMaterializedOntModel
                .listStatements(link.asResource(), hasRefPartnerSideAProperty, null).asScala
                .map(_.getObject)
                .filterNot(rdfNode => rdfNode.toString.equals(endpointA.toString))
                .nextOption()
            }
            .flatMap { endpointB =>
              /* Obtain object logical or physical portlist. */
              infModelOrMaterializedOntModel
                .listStatements(endpointB.asResource(), hasEIInvProperty, null)
                .asScala.nextOption()
                .map(_.getObject)
            }
            .flatMap { portlist =>
              /* Finally, obtain asset. */
              infModelOrMaterializedOntModel
                .listStatements(portlist.asResource(), hasIEInvProperty, null)
                .asScala.nextOption()
                .map(_.getObject)
            }
        }
    assets
  }

  private def getVulnerabilityOnAssetObjectProperty(config: Config, ontModel: OntModel) =
    ontModel.getObjectProperty(s"${config.secOntConfig.ns}#vulnerability_on_Asset")

  private def getVulnerabilityExploitedByThreatObjectProperty(config: Config, ontModel: OntModel) =
    ontModel.getObjectProperty(s"${config.secOntConfig.ns}#vulnerability_exploitedBy_Threat")

  def processCves(config: Config, ontModel: OntModel, resultSetBinding: ResultSetBinding): Option[OntModel] = {
    val queryResult = QueryExecutor.query(
      s =
        s"""
           |PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
           |PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
           |PREFIX owl: <http://www.w3.org/2002/07/owl#>
           |PREFIX amlImp: <http://www.ipr.kit.edu/aml_importer#>
           |PREFIX amlOnt: <http://www.ipr.kit.edu/aml_ontology#>
           |PREFIX icsSecOnt: <http://securityontology.com/icssecont#>
           |PREFIX secOnt: <http://securityontology.com/secont#>
           |SELECT DISTINCT ?cve ?cveId ?cpe ?version ?other ?part ?product ?productName ?vendor ?vendorName ?indvAml ?cvss ?cvssBaseScore
           |   WHERE {
           |      ?indvAml amlImp:hasCpePart ?part.
           |      ?indvAml amlImp:hasCpeVendor ?vendorName.
           |      ?indvAml amlImp:hasCpeProduct ?productName.
           |      ?indvAml amlImp:hasCpeVersion ?version.
           |   }
        """.stripMargin,
      model = ontModel,
      Some(resultSetBinding)
    )
    val vulnOntCls = ontModel.getOntClass(s"${config.secOntConfig.ns}#Vulnerability")
    val vulnerableSoftwareIndv = ontModel.getIndividual(s"${config.secOntConfig.ns}#VulnerableSoftware")
    val vulnerabilityCveDataProperty = ontModel.getDatatypeProperty(s"${config.secOntConfig.ns}#vulnerability_has_Cve")
    val vulnerabilityCvssDataProperty = ontModel.getDatatypeProperty(s"${config.secOntConfig.ns}#vulnerability_has_SeverityValue")

    queryResult.values.foreach { binding =>
      val cveIdentifier = queryResult.variables.find(_.getVarName == "cveId").map(binding.get)
      val amlIndv = queryResult.variables.find(_.getVarName == "indvAml").map(binding.get)
      val sepsesCveIndv = queryResult.variables.find(_.getVarName == "cve").map(binding.get)
      val sepsesCvssBaseScore = queryResult.variables.find(_.getVarName == "cvssBaseScore").flatMap(x => Option(binding.get(x))) // can be null, wrap with Option
      for {
        cveId <- cveIdentifier
        amlI <- amlIndv
        cveI <- sepsesCveIndv
        vulnIndv <- Some(ontModel.createIndividual(s"${config.secOntConfig.ns}#${cveId.toString.replace("\"", "")}", vulnOntCls))
      } yield {
        vulnIndv.addProperty(getVulnerabilityExploitedByThreatObjectProperty(config, ontModel), vulnerableSoftwareIndv)
        vulnIndv.addProperty(getVulnerabilityOnAssetObjectProperty(config, ontModel), ontModel.getIndividual(amlI.getURI))
        vulnIndv.addProperty(vulnerabilityCveDataProperty, ResourceFactory.createTypedLiteral(cveI.getURI, XSDDatatype.XSDanyURI))
        // In case CVSS exists, add property
        sepsesCvssBaseScore foreach {
          cvss => vulnIndv.addProperty(vulnerabilityCvssDataProperty, ResourceFactory.createTypedLiteral(cvss.getLiteral.getValue.toString, XSDDatatype.XSDdouble))
        }
      }
    }
    Some(ontModel)
  }


}
